<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308292 (ko-KR, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="525"/>

<div>
<span><div><div><b>파일 시스템 개요</b></div><ul><li><div>프로세스가 실행되는동안, 프로세스는 자신의 주소공간에 제한된 양의 정보를 저장할 수 있다</div></li><li><div>문제점</div></li><ol><li><div>저장가능 용량은 <span style="font-weight: bold;">가상주소공간의 크기로 제한!</span></div></li><li><div>프로세스가 종료할때 정보도 사라짐</div></li><li><div>종종 다수의 프로세스가 동시에 정보에 접근할 필요가 있다</div></li></ol></ul><div>                =&gt;해결책: 정보 자체를 프로세스들과는 관련이 없도록 만든다</div><div><br/></div><ul><li><div> 장기 기억정보 저장소를 위한 세가지 필수 요구사항</div></li><ol><li><div>저장소는 매우 큰 규모의 정보를 저장</div></li><li><div>정보는 그것을 사용하는 프로세스가 종료된 후에도 유지</div></li><li><div>다수의 프로세스가 동시에 정보에 접근</div></li></ol><li><div>디스크=고정된 크기의 블록들의 연속</div></li><ul><li><div>k번 블록 읽기</div></li><li><div>k번 블록 쓰기  </div></li><ul><li><div>대부분 위의 2가지 연산으로 해결가능</div></li></ul></ul><li><div>그러나 서버와 같이 다수의 응용이 실해오디고 다수의 사용자 존재시 <span style="font-weight: bold;">문제점</span></div></li><ol><li><div>정보를 어떻게 찾을것인가?</div></li><li><div>어떤 사용자의 정보를 다른사용자가 읽지 못하도록 할것인가?</div></li><li><div>어떤 블록이 가용상태인지 어떻게 알수 있는가</div></li></ol></ul><div><br/></div><ul><li><div>우리는 <span style="color: rgb(255, 0, 0);">파일이라는 추상화</span>를 통해 해결가능</div></li><ul><li><div>  운영체제가 프로세스 주소공간을 만들기위해 프로세서를 추상화하고, 물리주소공간을 가상주소공간으로 추상화와 비슷한 개념</div></li></ul><li><div>프로세스(스레드), 주소공간, 파일 =&gt; 운영체제에서 중요한 개념들          </div></li></ul><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="527"/>

<div>
<span><div><div><span style="font-weight: bold;">파일</span></div><ul><li><div>프로세스에 의해 생성된 정보의 논리적 단위</div></li><li><div>디스크는 ㅇ리반적으로 수천개, 수백만개의 파일을 지님</div></li><li><div>각각은 독립적</div></li><li><div>파일 정보는 영속적(persistent)</div></li><li><div>프로세스 생성, 종료에 영향을 받지 않는다</div></li><li><div>오직 소유자가 명시적으로 삭제 </div></li><li><div>파일은 운영체제에 의해 관리</div></li><li><div>조직화,명칭 부여, 접근, 사용, 보호, 구현, 관리</div></li></ul><div><br/></div><div><span style="font-weight: bold;">사용자 관점</span></div><ul><li><div>파일이 어떻게 보이는가 </div></li><li><div>파일은 무엇으로 구성</div></li><li><div>어떻게 이름 부여, 보호, 연산</div></li></ul><div><span style="font-weight: bold;">파일시스템 설계자 관점</span></div><ul><li><div>가용공간을 위해 연결리스트, 비트맵 사용여부</div></li><li><div>몇개의 섹터가 논리적인 디스크블록을 형성 </div></li></ul><div><br/></div><div><span style="font-weight: bold;">목차구성</span></div><ul><li><div>처음 2절은 파일과 디렉토리에 접근하는 사용자 인터페이스</div></li><li><div>다음은 파일시스템이 어떻게 구현되고 관리되는지에대한 설명</div></li><li><div>실제로 사용되는 파일시스템</div></li><li><div><br/></div></li></ul><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="529"/>

<div>
<span><div><div><b>사용자 관점에서 파일</b></div><div><br/></div><div><br/></div><div><b>1.1 파일 명칭 부여</b></div><ul><li><div>모든 추상호 메커니즘에서 가장 중요한 특징은 관리되는 객체에 이름을 부여하는것</div></li><li><div>프로세스는 파일을 생성할때 파일에게 이름 부여</div></li><li><div>다른 프로세스는 이름을 이용하여 접근</div></li><li><div>세부규칙은 시스템마다 상이, 한글자-8글자 텍스트 (보통 사용)  max 255까지 허용</div></li><li><div>UNIX는 대/소문자 구분 MS-DOS는 구분 x</div></li><li><div>window95/98-&gt;<b>FAT-16</b>이라는 MS-DOS 파일 시스템 이용  (98은 <b>FAT-32</b> 도입)</div></li><li><div>window NT/2000/XP/Vista -&gt; 내장 파일 시스템 <b>NTFS</b></div></li><li><div>파일 이름은 = 이름+ 확장자 </div></li><li><div>2개이상의 확장자 가능</div></li><li><div>UNIX에서는 확장자가 컴퓨터에게 실질 정보 제공 X</div></li><li><div>WINDOW는 확장자를 컴퓨터가 인식!</div></li></ul><div><br/></div><div><b>1.2 파일 구조</b></div><ul><li><div>운영체제 입장에서 다니 파일은 바이트들의 모음</div></li><li><div>의미 해석은 사용자수준의 프로그램 책임</div></li><li><div>바이트/레코드/트리</div></li><li><div>레코드</div></li><ul><li><div>구조화된 파일들</div></li><li><div>고정된 크기의 레도크들의 연속</div></li><li><div>각 레코드는 특별한 형태의 내부 구조 </div></li><li><div>읽기는 하나의 레코드 </div></li><li><div>쓰기는 하나의 레코드 변경/추가</div></li></ul><li><div>트리</div></li><ul><li><div>파일은 트리구조로 구성된 레코트들 지님</div></li><li><div>레코드 내부 고정된 위치에 키필드를지님</div></li><li><div>트리는 키 필드를 기준으로 정렬</div></li><li><div>특정 키에대한 빠른검색 가능</div></li><li><div>새로운 레코드 추가시 사용자가  아닌 운영체제에 의해 결정</div></li><li><div>이러한 구조는 UNIX /WINDOW에서 사용되는 비 구조화된 파일과 다르지만, 상용 데이터 처리에 사용되는 메인프레임 컴퓨터에 여전히 사용</div></li></ul></ul><div><b>1.3 파일유형</b></div><ul><li><div>여러 유형의 파일을 지원</div></li><li><div>정규파일,디렉터리,문자특수파일,블록특수파일</div></li><li><div>정규파일: 사용자정보 지님</div></li><li><div>디렉터리: 파일시스템 구조를 유지하기위해  사용되는 시스템 파일</div></li><li><div>문자특수 파일 : I/O장치와 연관, 터미널, 프린터, 네트워크 같은 문자I/O장치를 모델링 하기위해 사용</div></li><li><div>블록 특수파일: 디스크를 모델링하기위해 사용</div></li><li><div>주로 정규파일에대해 논의!</div></li><li><div>정규파일</div></li><ul><li><div>ASCII파일 또는 이진파일</div></li><li><div>ASCII파일: 텍스트 행들로 구성</div></li><li><div>어떤 시스템 경우 각 행의 끝은 <b>캐리지 리턴문자(carrage return)</b>에 의해 표현</div></li><li><div>다른 시스템은 <b>라인피드(line feed)</b>에 의해 표현</div></li><li><div>MS-DOS의 경우 이 두 문자가 모두 존재</div></li><li><div>ASCII장점</div></li><ul><li><div>별다른 처리 없이 표시/프린트 가능</div></li><li><div>텍스트 편집기로 편집가능</div></li><li><div>한 프로그램 출력을 다른 프로그램 입력으로 가능 =&gt; <b>쉘 프로그램의 파이프라인</b>과 관련</div></li></ul><li><div>이진파일 </div></li><ul><li><div>ASCII파일이 아니다</div></li><li><div>프린터 출력시 무의미한 정보로 보임</div></li><li><div>프로그램만이 해석할수 있는 내부 구조체 가짐</div></li><li><div>첫번쨰 실행파일</div></li><ul><li><div>매직너버: 헤더에 흔히 얘기하는 매직넘버로 시작, 이는 파일이 실행파일임을 표시</div></li><li><div>헤더 다음 텍스트와 데이터존재 =&gt; 메모리로 적재, 재배치 비트에 따라 재배치 </div></li><li><div>심볼 테이블은 디버깅 용도</div></li></ul><li><div>두번쨰 아카이브파일</div></li><ul><li><div>컴파일 되었으나 아직 연결 되지않은 라이브러리 프로시듀어(모듈)로 구성</div></li><li><div>헤더</div></li></ul></ul></ul><li><div>모든 OS는 적어도 하나의 파일유형, 자신만의 실행파일유형을 인식</div></li></ul><div><br/></div><div><b>1.4 파일 접근</b></div><ul><li><div>초기 OS는 순차접근(sequential access)이라는 한가지 종류의 파일접근을 지원</div></li><li><div>프로세스는 파일의 모든 바이트/레코드를 앞부분으로 순차적으로 읽어야함</div></li><li><div>건너 뛰거나/ 뒤바꿔서 읽을수 없었다</div></li><li><div><b>순차파일</b>은 디스크가 아닌 자기테이프 저장매체에 사용</div></li><li><div>디스크를 사용하면서, <font style="color: rgb(255, 0, 0);"><b>키값에 따라 레코드읽기 가능</b></font></div></li><li><div>파일/레코드는 임의 순서로 읽는것이 가능한 <b>임의접근파일 가능</b></div></li><li><div>어디서부터 읽을지 2가지 기법 사용가능</div></li><ul><li><div>모든 read연산마다 파일내에서 읽을 위치를 지시</div></li><li><div><font style="color: rgb(255, 0, 0);"><b>seek라는 특별한 연산이 현재 위치를 지정=&gt;seek 실행후 현재 위치부터 파일을 순차 읽음 =&gt;UNIX/WINDOW 현재 사용</b></font></div></li></ul></ul><div><span>    </span><br/></div><div><span><b>1.5 파일속성</b></span></div><ul><li><div><span>모든 파일은 이름과 데이터를 지님</span></div></li><li><div>마지막 변경날짜/시간/파일크기 같은 추가정보=&gt; <b>속성 또는 메타 데이터 Meta Data</b></div></li><li><div>이 속성은 시스템마다 다르다</div></li></ul><div><br/></div><div><b>1.6 파일 연산들</b></div><ul><li><div>생성 create-파일 생서과 몇개의 속성을 설정</div></li><li><div>삭제 delete-디스크 공간을 반납</div></li><li><div>오픈 open-파일을 사용하기전에 프로세스는 파일을 열어야한다.</div></li><ul><li><div>시스템이 속성을 검사하고, 파일 디스크주소를 메모리로 읽어 뒤따라오는 호출들의 파일접근을 빠르게!</div></li></ul><li><div>닫기 close-접근이 끝나면, 속성과 디스크주소는 더이상 필요 x</div></li><ul><li><div>내부 테이블 공간 반환</div></li><li><div>많은 시스템은 <b>프로세스당 열수 있는 파일의 최대개수를 제한!!!</b></div></li><li><div>디스크로의 기록은 블록단위</div></li><li><div>파일의 마지막 블록은 완전히 채워지지 않을수도있지만, 파일닫기는 파일의 마지막블록도 디스크에 기록되도록 강제</div></li></ul><li><div>읽기 read-파일로부터 데이터 읽음. 현재위치로부터 바이트들 읽음, 읽을 데이터지정 + 저장할 버퍼 제공</div></li><li><div>쓰기write-데이터를 파일에 기록. 현재위치부터 기록. 현재위치가 파일 끝이면 크기는 증가!</div></li><li><div>덧붙이기 append-파일의 끝에 데이터를 추가하는 기능</div></li><li><div>탐색 seek-파일 임의접근 위하여 데이터를 어느 위치로부터 읽을지 지정하는 기법</div></li><ul><li><div>시스템호출-seek이며, 탐색은 파일 특정위치로 파일포인터를 변경</div></li></ul><li><div>속성 가져오기 get attributes - 프로세스는 해당 작업을 위해 종종속성을 가져와야할 경우</div></li><ul><li><div><b>UNIX make 프로그램 예</b> - 많은 소스 파일들로 구성된 소프트웨어를 관리하기위해 이 프로그램이 사용</div></li><li><div>모든 소스와 목적파일들의 변경시간을 검사, 모든것을 최신상태로 빌드하기 위해 최소파일들만 컴파일</div></li><li><div>이를 위해 파일속성, 정확히 변경시간을 검사</div></li></ul><li><div>속성 설정하기 set attributes</div></li><li><div>명칭변경 rename</div></li><li><div><br/></div></li></ul><div><b><br/></b></div><div><b><br/></b></div><div><b>1.7 파일 copyfile abc xyz 예제</b></div><ul><li><div>파일 디스크럽터 file descriptor : 파일이 열릴때 반환되는 정수 값</div></li><li><div>read/write 시스템 호출에서 반환되는 바이트 카운트값</div></li><li><div>읽은 데이터/쓰여질 데이터 임시저장을 위한 buffer</div></li><li><div>exit(0) 정상 종료</div></li><li><div><br/></div></li></ul><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><br/></div></div></span>
</div>
<hr>
<a name="657"/>

<div>
<span><div><ul><li><div>apt upgrade &amp;&amp; apt update 에러 </div></li><ul><li><div>/tmp에서 read-only라서 쓰기 권한문제 =&gt;권한 설정으로 해결</div></li></ul></ul><div><br/></div></div></span>
</div></body></html> 